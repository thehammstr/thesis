% !TEX root = ../Thesis.tex

\chapter{Fusing Multiple Data Swaths via GraphSLAM}
\label{ch.GraphSLAM}

Chapter \ref{ch.IcebergGeometry} recast the problem of iceberg mapping in a form very similar to traditional static terrain mapping problems. The vehicle's trajectory through the iceberg frame of reference can be dead-reckoned based on the DVL measurements, and the iceberg's rotation is can be modeled as a drifting rate gyro bias or low-precision compass, both of which have been dealt with extensively in the robotics community.

A number of techniques can be applied to solve this new formulation of the mapping problem. Many of these techniques have been developed extensively in the robotics community, and a number of powerful software tools are available to solve the techniques' associated optimizations. While a number of these methods could have been used for profiling icebergs, the ease of representing the problem as a pose graph, the ability to solve large optimizations efficiently, and the fact that the calculations did not need to be performed online drove the selection of GraphSLAM as a solution method. 

This chapter will give a brief overview of the mechanics of Graph SLAM, advantages of the method, and a description of how the typical vehicle state definition was modified in order to accomodate the errors associated with iceberg motion. Additionally, there will be a discussion of how different sensing modalities and error modes could drive choices for alternative state definitions. However, it will not go into the low-level details of how the GraphSLAM algorithm implements its optimization. For more detail on that, the reader should refer to the sources in the related works section.

\section{GraphSLAM overview}

\begin{figure}[htbp]
   \centering
   \includegraphics[width=.7\textwidth]{../graphics/factor_graph.png} % requires the graphicx package
   \caption{Graph representation of mapping problem.  The poses $x_i$ and $x_{i+1}$ are linked via odometry terms. Additionally, any two poses where the same landmark was observed are linked by measurement terms through that landmark. These links represent Gaussian conditional probabilities. \emph{PLACEHOLDER GRAPHIC}}
   \label{fig:GraphSLAM}
\end{figure}

\subsection{Mapping as a probabilistic graph}

GraphSLAM represents the mapping problem as a probabilistic graph. This can be visualized as a collection of connected nodes, as in Figure \ref{fig:GraphSLAM}. Some nodes represent vehicle poses, $x_t$, while others [optionally] represent locations and characteristics of features in the map, $m_j$. 

The links between the nodes encode pairwise information about how nodes are related to each other, either through odometry or measurement of the environment. Specifically, the algorithm models each link as giving the conditional probabibility distribution of a node given its linked node, and models this distribution as a Gaussian. For example, consier two pose estimates $x_t$ and  $x_{t+1}$ and nonlinear motion model $g(x_t,u_t)$, where $u_t$ is the control input at time $t$. The graphical link between $x_t$ and  $x_{t+1}$ represents the probability distribution: 

\begin{align}
p\left(x_{t+1}~|~x_t,u_t\right) & \sim \mathcal{N}\left(g(x_t,u_t), R_t\right)
\label {eq:Gauss1}
\end{align}

where $R$ is the process noise covariance matrix. Note that this representation is identical to that of the Extended Kalman Filter (EKF) motion model, normally written 
\begin{align}
x_{t+1} &= g\left(u_t,x_t\right) + \nu_p\\
R &\equiv E\left(\nu_p \nu_p^\intercal\right) 
\end{align}

In GraphSLAM variants with explicit map representation, poses are connected to map nodes via measurement links. If a measurement $z^i_t$ of map feature $m_j$ is made at time $t$, then $x_t$ and $m_j$ are linked via the measurement function $h \left(x_t,m_j\right)$ such that 

\begin{align}
p\left(z^i_{t}~|~x_t,m_j\right) & \sim \mathcal{N}\left(h(x_t,u_t), Q_t\right)
\label {eq:Gauss2}
\end{align}

Here, $Q$ is the measurement covariance. Again, this is equivalent to the EKF measurement update

\begin{align}
z_{t} &= h\left(x_t,m_j\right) + \nu_m\\
Q &\equiv E\left(\nu_m \nu_m^\intercal\right) 
\end{align}

The full posterior probability of the graph is then given by the product of all these conditional terms. Solving for the maximum likelihood estimate requires finding the combination of free parameters (nodes) that maximizes this posterior probability. 

\subsection{GraphSLAM as nonlinear least squares}

The graph can be optimized via a nonlinear least squares approach. To see this, Equations \ref{eq:Gauss1} and \ref{eq:Gauss2} are expanded by the definition of the Normal distribution.

\begin{equation}
p\left(x_{t+1}~|~x_t,u_t\right) = \eta~ exp\left(-\frac{1}{2}\left[x_{t+1} - g\left(u_t,x_t\right)\right]^{\intercal}R_t^{-1}\left[x_{t+1} - g\left(u_t,x_t\right)\right]\right)
\end{equation}

\begin{equation}
p\left(z^i_{t}~|~x_t,m_j\right) = \eta~ exp\left(-\frac{1}{2}\left[z^i_{t} - h\left(x_t,m_j\right)\right]^{\intercal}Q_t^{-1}\left[z^i_{t} - h\left(x_t,m_j\right)\right]\right)
\label{eq.measModel}
\end{equation}

Taking the log of the full joint probability yields a sum of quadratic terms:

\begin{multline}
J = ~x_0^{\intercal}\Omega_0 x_0 ~+
\sum_{t}{\left[x_{t+1} - g\left(u_t,x_t\right)\right]^{\intercal}R_t^{-1}\left[x_{t+1} - g\left(u_t,x_t\right)\right]} ~+ \\ \sum_{t}{\sum_{i}{\left[z^i_{t} - h\left(x_t,m_j\right)\right]^{\intercal}Q_t^{-1}\left[z^i_{t} - h\left(x_t,m_j\right)\right]}}
\label{eq.quadcost}
\end{multline}

The first term is necessary to ``anchor" the map, since all other constraints are purely relative between poses. In effect, it fixes the first point to the origin. 

The maximum likelihood estimates for all free parameters $x_t$ and $m_j$ in the optimization are those that minimize this cost function, $J$.

\subsection{Minimum spring energy analogy}

A useful analogy for gaining intuition into how the GraphSLAM solver works uses the concept of spring potential energy. 

\begin{align}
P_{\text{spring}} &= \frac{1}{2}k\left(l-l_n\right)^2
\label{eq.spring}
\end{align}

Note the similarity between equation \ref{eq.spring} and the right hand side terms of equation \ref{eq.quadcost}. All of them are weighted quadratic functions.

In this analogy, each graph link is modeled as a spring separating the nodes, as shown in Figure \ref{fig:springs}. The natural length $l_n$ of the spring corresponds to the mean of the conditional probability,  $g\left(u_t,x_t\right)$ for odometry, and $h\left(x_t,m_j\right)$ for measurements. The stiffness $k$ is inversely proportional the covariance $R$ or $Q$: the more certain the measurement, the stiffer the effective spring. 

Once the nodes are all tied together with springs of appropriate length and stiffness, any deviation from the natural length will result in additional spring potential energy. The GraphSLAM solution is identical to the \emph{minimum energy} state of this system. In fact, if the nodes were modeled as masses, and viscous damping were applied, dynamic motion simulation could be used to compute the same solution as GraphSLAM. The system would ``relax" into its minimum energy state, and the steady state dynamic solution would be the GraphSLAM MLE solution. While such a method would likely be much slower than using the actual GraphSLAM solution algorithm, the idea of modeling the system as a collection of masses, springs, and dampers provides useful intuition on how the algorithm manipulates the parameters to arrive at a solution.

\begin{figure}[htbp]
   \centering
   \includegraphics[width=.65\textwidth]{../graphics/springs.png} % requires the graphicx package
   \caption{GraphSLAM is equivalent to the minimum energy configuration of a mass-spring-damper system. Each spring's natural length and stiffness are determined by the corresponding measurement and measurement covariance, respectively.}
   \label{fig:springs}
\end{figure}


\subsection{Advantages of the GraphSLAM method}

GraphSLAM provides a solid theoretical framework for modeling errors associated with the mapping task, can be used to solve very large problems efficiently, and has a wide enough user base that there already exist optimized solvers, enabling fast application to the problem of profiling icebergs.

The reformulation of the iceberg mapping problem detailed in Chapter \ref{ch.IcebergGeometry} can be solved using the modified form of Kimball's method, shown in Figure \ref{fig:NestedLoop2} with the deterministic inner loop. However, the elimination of the inner loop optimization carries the implicit assumption that any error comes entirely from the iceberg's rotation. In reality, there will be other errors due to measurement and odometry noise that should be considered alongside the rotational error to produce a map of the highest quality possible. 

GraphSLAM provides a theoretical framework that allows the error associated with each quantity to be weighted according to its uncertainty relative to all other measurements. This serves to provide better justification for the weighting terms used in the map optimization, addressing one of the areas of future work proposed by Kimball. Additionally, the structure used by GraphSLAM to represent the mapping problem allows it be used to solve large mapping problems very efficiently. For an illustration of this, Montemerlo et. al. calculated a map of Stanford's Main Quad, including $10^5$ poses and $10^8$ range measurements in roughly 30 seconds of CPU time \cite{?}. This is the same order of magnitude problem size as the iceberg profiling problem considered in this thesis.

Another attractive aspect of using GraphSLAM to solve the iceberg profiling problem is that there exist a number of efficient, optimized, and easy-to-use software libraries to solve such graph optimization problems. Of these, an open source nonlinear least-squares graph solver library called Ceres was used. This library was initially developed by Google for in-house use on Google Maps' street view feature, stitching images together into a self-consistent map. They later released it for public development, and it has been used by a number of universities and research institutions for SLAM, bundle adjustment, and a number of other robotics tasks. \cite{ceres}


%\Omega = \left[\begin{array}{c c c c c | c c c c}
%u_{1,1} & u_{1,2} &     0   & 0 & 0 &  z_{1,1} & \hdots & z_{1,i} & 0 \\
%u_{1,2} & u_{2,2} & \ddots & 0 & 0 &  z_{2,1} & \hdots & z_{2,j} & 0 \\
%0       & \ddots & \ddots &     \ddots  &   0    &    \ddots     &    \ddots   &    \ddots & 0    \\
%0 & 0 & \ddots & u_{n-1,n-1} & u_{n,n-1} & 0 & \ddots & \ddots & \vdots \\
%0 & 0 & 0 & u_{n,n-1} & u_{n,n} & 0 & \hdots & z_{n,m-1}  & z_{n,m}\\
%\hline 
%z_{1,1} & z_{2,1} & 0 & 0 & 0 & l_{1,1} & 0 & 0 & 0\\
%\vdots & \vdots & 0 & 0 & z_{n,m-1} & 0 & \ddots & 0 & 0 \\
%\vdots & \vdots & 0 & 0 & z_{n,m-1} & 0 & 0 & \ddots & 0 \\
%\vdots & \vdots & 0 & 0 & z_{n,m} & 0 & 0 & 0 & l_{m,m} 
%\end{array}\right]
%, ~\xi = \left[\begin{array}{c}
%p_1 \\
%p_2 \\
%\vdots \\
%p_{n-1} \\
%p_n \\
%\hline
%m_1 \\
%m_2 \\
%\vdots \\
%m_m
%\end{array}\right]

\subsection{Choice of map representation}

GraphSLAM can be implemented with either explicit or implicit map representations. This section weighs the merits of each approach as it relates to the task of iceberg profiling.

\subsubsection{Implicit map}
The implicit map representation uses information in terrain that has been viewed multiple times, but encodes that information directly in pose-to-pose constraints, effectively creating a ``pseudo-odometry" link. By correlating submaps built from concatenated measurements, translational and rotational offsets between poses can be estimated and enforced directly between pose nodes. 

This approach is useful when the information in the terrain is dispersed throughout, as opposed to being concentrated in well-localized recognizable landmarks. This is often the case when the vehicle navigates through natural terrain using a range scanner with a wide field of view. In these scenarios, larger scale correlation may provide better offset data than local features. 

One downside of using this method with the sensors available onboard is that it can fall prey to the submap warping described in Chapter \ref{ch.LoopClosure}, as many planar scans must be concatenated together over time, assuming that the vehicle's motion through the iceberg's reference frame is well modeled. If this assumption is not valid, the point cloud registration techniques that drive this approach can suffer from reduced accuracy or fail altogether, yielding map inconsistencies. 

Another potential source of error in this method arises from the difficulty of quantifying the uncertainty introduced into the mapping optimization based on the registration results. Stated another way, choosing the appropriate relative weights for the pseudo-odometry links in the GraphSLAM optimization can be difficult, and links between those weights and hard, quanifiable parameters like sensor noise specifications are more tenuous.  

Based on its ability to work in terrain with diffuse data, the implicit map formulation is used in the results presented in Chapter \ref{ch.Results}.


\subsubsection{Explicit map} 

In the explicit map variant of GraphSLAM, the locations of features within the map are solved alonside the vehicle trajectory. This is often used when the map consists primarily of discrete features, such as passive beacons \cite{?}, trees or pilings \cite{Langellaan}, or robust image features \cite{Augenstein}.

This method circumvents the problem of submap warping by distilling the information contained in the terrain to a single point. Since no point cloud registration is used, there is no need to make a small motion assumption for the iceberg, which  would be advantageous for fast-moving objects. However, there must be enough local information to form a discrete, recognizable feature. Doing this with range data alone in natural terrain can be challenging. 

In underwater mapping of natural terrain, including icebergs, it can be difficult to identify individual features with enough distinctiveness that they can be reliably used for mapping. However, early work published by the author has made some advances into leveraging understanding about the terrain to make features in sonar data more distinctive. Future work in this area, including the use of sonar intensity return, may eventually make this representation more attractive.


\subsection{Known vs. unknown correspondence}

An important factor in any SLAM problem is solving the \emph{correspondence problem}, that is identifying measurements that observe the same feature or area in the terrain. The most basic GraphSLAM algorithm can be perfomed where correspondence is estimated beforehand or known a priori. However, more advanced variants can attempt to detect and incorporate new correspondences or loop closure events as the mapping optimization is being performed. Additionally, initial correspondences can be broken if information arises to suggest that a corresponce was identified falsely. 

The results presented in Chapter \ref{ch.Results} were generated by a formulation of GraphSLAM using pre-computed correspondences, as described in Chapter \ref{ch.LoopClosure}. Possible future implementations that discover correspondences as the algorithm progresses will be discussed in Chapter \ref{ch.FutureWork}.

\section{Applying GraphSLAM to iceberg profiling}

Thus far, a high-level overview of the GraphSLAM algorithm has been presented, along with several design considerations for its implementation. This section describes in detail how all the components of iceberg profiling, from loop closure to iceberg-relative motion, can be combined within the GraphSLAM framework to  yield an accurate reconstruction. 

More specifically, it is now required that all the components in the conditional probability relations (restated here for convenience) be defined, all modeling assumptions be stated clearly, and choices of relative weights be justified. 

\begin{align}
p\left(x_{t+1}~|~x_t,u_t\right) & \sim \mathcal{N}\left(g(x_t,u_t), R_t\right) \\
p\left(z^i_{t}~|~x_t,m_j\right) & \sim \mathcal{N}\left(h(x_t,u_t), Q_t\right)
\end{align}

\begin{figure}[htbp]
   \centering
   \includegraphics[width=.7\textwidth]{../graphics/placeKitten1.jpeg} % requires the graphicx package
   \caption{Inputs and outputs of GraphSLAM\emph{PLACEHOLDER GRAPHIC}}
   \label{fig:GraphSLAMIO}
\end{figure}

\subsection{State and motion models}

The state and models used in GraphSLAM depend on the modeling assumptions of both the vehicle and the iceberg. These are stated here, and used to create a reduced state representation and kinematic motion model to feed into GraphSLAM

\subsubsection{Vehicle motion model}

\subsubsection{Iceberg motion model}

\subsubsection{GraphSLAM state $\left[~x_t~\right]$}

\subsubsection{GraphSLAM motion model $\left[~g\left(x_t,u_t\right)~\right]$ }

\subsection{Sensor model}

Multibeam and DVL, including dvl dropouts

%################

The approach to modeling the iceberg mapping problem depends on the vehicle characteristics and what sensing it has available to it. This section assumes a vehicle as described in Section \ref{sec.VehicleSetup}, namely a torpedo-shaped AUV with sideways-facing DVL and multibeam sonar. Other vehicle and sensor configurations may benefit from different representations. A brief discussion of these considerations is given at the end of this section. 

\subsection{State model}

The state representation is as follows: 

\begin{equation}
\label{eq.state}
\vec{x}= \left[\begin{array}{c}
                     x \\ y \\ \psi \\ \beta 
                     \end{array}\right]
\end{equation}

This is a common 2D-planar robotic mapping state representation, augmented with a drift rate term, $\beta$ to account for the iceberg's rotational motion.

It is assumed that the vehicle depth could be measured directly by onboard pressure sensors, reducing the problem to two dimensions in translation, denoted $x$ and $y$. This is a reasonable simplification for iceberg profiling. In mapping static terrain, low frequency tidal offset effects must often be estimated, but since an iceberg floats with the tides, this is not a concern. Large amplitude waves can also introduce depth errors, but at much higher frequencies than the tides. These effects can be mitigated by combining integrated DVL-measured vertical velocity for high frequencies and depth sensor for low frequencies in a complementary filter framework.

Section \ref{sec.MainContrib} showed that the sideways-facing DVL could be used to directly measure the body components of the vehicle's velocity in the iceberg frame of reference. However, the vehicle's heading in the frame of reference of the iceberg, $\psi$, can not be directly measured with the assumed sensor suite, and must be estimated in the SLAM framework. The iceberg angular drift rate can be safely assumed to be relatively small, and to change slowly due to the large inertia of the iceberg, but may have nonzero mean value over the course of the mapping run. This drift is labeled $\beta$. 

A kinematic motion model is used, such that

\begin{align}
x_{t+1} &= x_t + \left[cos(\psi) u_t + sin(\psi)v_t\right]\Delta t +~ \nu_x\\
y_{t+1} &= y_t + \left[-sin(\psi) u_t + cos(\psi)v_t\right]\Delta t + ~\nu_y \\
\psi_{t+1}    &= \psi_{t} + \left[\omega_t- \beta_t \right] \Delta t + ~\nu_\psi\\
\beta_{t +1}   &= \beta_{t} + ~\nu_\beta
\end{align}

The translational motion update is driven by the DVL. That is, the velocity of the vehicle's center of mass in the iceberg frame, expressed in vehicle-frame coordinates. 

\begin{equation}
\vec{u}_\text{\tiny{DVL}}(t) = 
                    \left[\begin{array}{c}
                     u_t \\ v_t \\ w_t 
                     \end{array}\right]_V
\end{equation}

The vehicle's rotational motion update is driven by the vehicle's heading rate gyro measurement $\omega_t$ and the estimated iceberg motion parameter, $\beta_t$.  The iceberg's large mass and inertia guarantee that its angular rate will be both small and slowly-varying. To capture this, $\beta_t$ is modeled as a random walk, driven only by noise.

Each motion update also has a process noise term $\nu_i$. These are zero-mean Gaussian random variables whose covariance is tuned to reflect the uncertainty of the process. For translation, this is primarily DVL velocity measurement accuracy, for rotation, this is gyro accuracy, and for $\beta$ this is loosely related to the inertia of the iceberg. 

A state representation without the drift term $\beta$ could have been used, increasing the process noise covariance on the heading to account for unmodeled drift of the iceberg. This would result in the same state representation typically used in mobile (wheeled) robotic SLAM problems, as in \cite{ProbRob}. However, the zero-mean uncorrelated process noise assumption would have biased the navigation estimate, consistently underestimating any DC-component of the angular rate of the iceberg. For this reason, explicit modeling of the rotational drift rate was selected.

\subsubsection{Equivalence to compass error}

The iceberg drift parameter label $\beta$ is often used to indicate sensor bias. This nomenclature was chosen to highlight the equivalence of unmodeled iceberg motion and time-varying rate gyro bias. Navigating in a non-inertial reference frame using perfect inertial sensors is equivalent to navigating in an inertial reference frame with flawed inertial sensors. 

This equivalency allows the same mapping framework to be used for more traditional static mapping problems where the inertial sensing is less precise, such as a vehicle with low-cost sensors. The only underlying assumption is that the sensor bias changes on a time scale much slower than the vehicle dynamics. This holds true in the iceberg case due to the large inertia of the ice, and is also a valid assumption for many low-cost MEMs-type inertial sensors, where temperature fluctuations are the largest source of drifting biases \cite{citationneeded}. Depending on the expected error modes, other modeling considerations may be necessary. This will be discussed in section \ref{sec.DesignConsiderations}.

\subsection{Measurement model}

The measurement model used in a GraphSLAM implementation depends on the sensor type and configuration as well as the type of map representation used. The results presented in Chapter \ref{ch.Results} use an implicit map, an explicit map may be beneficial in future work for automating loop closure and abstracts the raw measurements less. Therefore, a method is discussed for each.

\subsubsection{Implicit map}

Performing GraphSLAM with an implicit map involves the abstraction of many observations of points on the iceberg surface to a single pose-to-pose synthetic measurement. This has the advantage of being able to describe succinctly any scattered loop closure information, but makes it more difficult to characterize accurately the errors associated with the measurement. 

The procedure is as follows: 


\begin{algorithm}
\DontPrintSemicolon
\SetAlgoLined
\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
\SetKwData{MapOne}{map1}\SetKwData{MapTwo}{map2}
\Input{Vehicle Trajectory \& Measurements, $t_1$, $t_2$}
\MapOne $\leftarrow$ BuildSubmap($t_1$,$W$) \;
\MapTwo $\leftarrow$ BuildSubmap($t_2$,$W$)\;
[$R$, $t$] $\leftarrow$ ICP(\MapOne,\MapTwo) \tcc*{point cloud registration} \;
Extract rotation offset from $R$ , translation from $t$\;
\Output{2D translation and 1D rotation offset between poses $\vec{x}(t_1)$ and $\vec{x}(t_2)$ }
 \caption{Implicit map ``measurement" synthesis}
\end{algorithm} 

Map registration algorithms like Iterative Closest Point vary in their implementation, computational complexity, and robustness to bad initializations. Improving on these techniques is a major area for future improvement, as validation of ICP alignments is the part of the data pipeline requiring greatest human oversight in the current implementation.\\


\begin{algorithm}[H]
\DontPrintSemicolon
\label{alg.submap}
\SetAlgoLined
\SetKwInOut{Input}{Input}\SetKwInOut{Output}{Output}
\Input{Center pose, $t_c$, and submap halfwidth, W}
subcloud = [~] \;
\For{ $t_c - W< t <t_c+W$}{
Project measurements $z_t^i$ into $t_c$ frame of reference\;
Add projected measurements to subcloud \;
}
\Output{subcloud }
\caption{BuildSubmap() \label{BSM}}
\end{algorithm}
~\\

Using this implicit map formulation has several advantages. Point cloud registration, or ``scan matching," performs well when there are not many strong, highly recognizable features in the data, but many weaker ones. This is the case when mapping natural terrain: there are not generally straight lines or sharp corners, but many gentle curves and ripples. Taken individually, these features are not very discernable from one another, but when considered as a collection, including their locations relative to one another, they can create a unique signature that can be recognized. Point cloud registration essentially does this automatically, by matching entire pointclouds to one another based on geometry, rather than attempting to match individual points within the clouds.

The implicit map formulation also bypasses the marginalization step of the GraphSLAM optimization, solving a smaller problem per iteration and converging more quickly. 

There are drawbacks, however. A large one is the underlying assumption that the drift of the iceberg is negligible during the time interval whose measurements form the submap. In general, this is not true, and errors due to motion will manifest as warping of the submap. This effect can introduce registration error, but can be mitigated by using as short an interval as possible while maintaining sufficient texture to register point clouds. However, this pressure to shrink the submap makes the correspondence problem more challenging, as smaller submaps are less likely to overlap. It is possible to recompute the pose-to-pose offsets calculated by point cloud registration during the optimization, but the computational cost may be significant, and coupling between the registration and solver may cause instability in the solution. 

Another challenge is determining how synthetic measurements should be weighted in the optimization. Assigning uncertainty to the synthetic measurement becomes challenging, as the pose offsets are obtained from many aggregated measurements. The error statistics can no longer be generated from known sensor error characteristics. Some mapping implementations solve this issue by assuming that point cloud alignment is perfect, and treating the calculated offsets as constraints, rather than penalty terms. The approach presented in this dissertation uses heuristics to determine the weight to be given to these synthetic measurements based on convergence speed, general sensor characteristics, and qualitative map consistency. 



\subsubsection{Explicit map}

Using an explicit map makes the error characterization of the measurement model more straightforward, but introduces correspondence challenges when applied to the type of terrain encountered in iceberg profiling. 

The measurement model used in the explicit map case represents the actual physics more closely than registering concatenated point clouds. The sonar can be characterized such that the covariance matrix of each individual return is known, and that information can be added directly to the information matrix. This is the matrix $Q_t$ in Equation \ref{eq.measModel}.

\begin{figure}[htbp]
   \centering
   \includegraphics[width=.9\textwidth]{../graphics/measModel.png} % requires the graphicx package
   \caption{Using an explicit map makes error characterization of the measurement model straightforward. The measured range is modeled as a Gaussian with mean $z_t^i$ and covariance $\sigma_{a}$ along the beam and $\sigma_{x}$ across the beam.}
   \label{fig:GraphSLAMmeasModel}
\end{figure}


\section{Application-specific design considerations}

The state and measurement models described above are appropriate for the types of errors one expects to encounter when profiling free-drifting icebergs. Other vehicle configurations or different missions may benefit from other representations: modeling is highly application-specific, and requires careful thought on the part of the engineer. Presented here is a discussion of several cases that differ from the mission and/or vehicle configuration assumed above, and possible ways to account for these differences.

\subsection{DVL as measurement instead of input}

The state representation presented above made the implicit assumption that the DVL remained in ``bottom lock" on the iceberg the majority of the time. At higher standoff distances, this may not be the case. In such instances, it may be advantageous to model the velocity as well as the position of the vehicle, and treat the DVL as a measurement (which it is, in reality) as opposed to an input.

\begin{equation}
\label{eq.altState}
\vec{x}= \left[\begin{array}{c}
                     x \\ y \\ u \\ v \\ \psi \\ \beta 
                     \end{array}\right]
\end{equation}

\begin{align}
\vec{v}_{t+1} &= \vec{v}_t + \left( \vec{a}_t + \vec{\omega}_t \times \vec{v}_t \right)dT\\
\end{align}

where $\vec{v}_t$ is the velocity of the vehicle in the iceberg frame, expressed in body coordinates, and $\vec{a}_t$ is the measured acceleration.
 
\begin{align}
\vec{v}_{t} &=  \left[\begin{array}{c}
                     u_t \\ v_t \\ w_t
                     \end{array}\right]_V
\end{align}

This state representation would enforce continuity in the velocity, and enable any and all DVL information to be incorporated, even if there are not enough beams in contact with the iceberg to measure full 3D velocity.

\subsection{Sensor pitch and roll bias}

Sometimes, a vehicle is assembled with a constant rotational misalignment or translational error between sensors. This can introduce systematic errors to the optimization.

If it is believed that such constant errors are present and large enough to corrupt the final map, an additional node corresponding to this constante vehicle state can be introduced, and estimated alongside the dynamic parameters. The difference between this and the situation considered in the previous section is that the error term is assumed to be constant throughout the mapping run. 

A link is drawn between every pose node and the node representing constant vehicle offsets. For very large problem size, this increase in connectivity of the graph can slow the optimization. In such cases it may be advantageous to calibrate the data using a subset of the measurements, and fix the calibrated parameters for the overall optimization. 

\subsection{Other sources of error}

Low-cost vehicles may lack DVL entirely, in which case it would be essential to estimate velocity as part of the state. In addition, any time-varying sensor biases can be incorporated in similar fashion to the iceberg's rotation bias term. This is often done on all axes of low-cost MEMs rate gyros, where bias varies with ambient temperature. 

More error states can be appended to the state to estimate such additional errors, but not without risk. Higher dimension state spaces increase the size of the optimization, but more importantly, can give optimizers more places to ``hide" errors. Care must be taken to avoid having the optimizer exploit such state augmentations and produce nonphysical results, unless the plant model is known to a high degree of accuracy.
 
\label{sec.DesignConsiderations}

\section{Summary}

GraphSLAM is a method well-suited to the problem of mapping icebergs. Its structure allows efficient solution of large mapping problems, and provides a convenient theoretical framework to describe the odometry and sonar measurements that drive the mapping process. With minimal augmentation to the state representation, the errors introduced by iceberg rotational motion can be accounted for, and additional augmentation can account for other error modes, if necessary. Finally, the GraphSLAM framework allows many swaths of data including multiple loop closure events to be incorporated in a single batch optimization, which is an improvement over prior art.